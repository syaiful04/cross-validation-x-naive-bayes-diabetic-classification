# -*- coding: utf-8 -*-
"""Cross Validation x NaiveBayes-Diabetic.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IfTE28pGV1JuvcesFMCPxUUpk_Bz7e3V
"""

import numpy as np
import pandas as pd
import matplotlib as plt
import seaborn as sns
import matplotlib.pyplot as plt
import itertools
import statistics
from sklearn.metrics import matthews_corrcoef
from sklearn.model_selection import cross_val_predict
from sklearn.model_selection import cross_val_score
from sklearn.naive_bayes import GaussianNB
from sklearn import metrics
from sklearn.metrics import classification_report, confusion_matrix
from sklearn.metrics import accuracy_score
from google.colab import files
df = files.upload()
df = pd.read_excel("DATA PASIEN (numeric).xls")

print(df.head())

df.isnull().sum()

df.info()

sns.boxplot(x='CLASS', y='STDEVPA', data=df)

x=df.drop(['CLASS','STDEVPA','AVERAGE'], axis=1)
y=df['CLASS']
model=GaussianNB()
score = cross_val_score (model, x, y, cv=10)
y_pred = cross_val_predict (model, x, y, cv=10)
conf_mat = confusion_matrix(y, y_pred)

score

y_pred

print("Accuracy: %f" % (score.mean()*100))

print(conf_mat)

print(classification_report(y,y_pred))

print('MAE:', metrics.mean_absolute_error(y, y_pred))
print('MSE:', metrics.mean_squared_error(y, y_pred))
print('RMSE:', np.sqrt(metrics.mean_squared_error(y, y_pred)))

print(matthews_corrcoef(y, y_pred))

classes = [0, 1]
# plot confusion matrix
plt.imshow(conf_mat, interpolation='nearest', cmap=plt.cm.Greens)
plt.title("Confusion Matrix")
plt.colorbar()
tick_marks = np.arange(len(classes))
plt.xticks(tick_marks, classes)
plt.yticks(tick_marks, classes)

fmt = 'd'
thresh = conf_mat.max() / 2.
for i, j in itertools.product(range(conf_mat.shape[0]), range(conf_mat.shape[1])):
    plt.text(j, i, format(conf_mat[i, j], fmt),
             horizontalalignment="center",
             color="white" if conf_mat[i, j] > thresh else "black")

plt.tight_layout()
plt.ylabel('True label')
plt.xlabel('Predicted label')

f, ax = plt.subplots(figsize=(9,7))
sns.heatmap(confusion_matrix(y, y_pred), annot=True, fmt="0.1f", ax=ax)
plt.xlabel("Predicted Table")
plt.ylabel("Actual Table")
plt.title("CONFUSION MATRIX")
plt.show()